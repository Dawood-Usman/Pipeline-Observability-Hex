package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.37

import (
	"context"
	"fmt"
	"myginapp/graph/model"

	"strconv"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo/options"
)

// CreateTodo is the resolver for the createTodo field.
func (r *mutationResolver) CreateTodo(ctx context.Context, input model.NewTodo) (*model.Todo, error) {
	// Query the database to find the highest existing ID
	collection := r.MongoDB.Database("admin").Collection("todos")
	findOptions := options.Find()
	findOptions.SetSort(bson.D{{"id", -1}}) // Sort by ID in descending order to get the highest ID first
	findOptions.SetLimit(1)                 // Get only the highest ID

	var highestID int
	cursor, err := collection.Find(ctx, bson.D{}, findOptions)
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)

	for cursor.Next(ctx) {
		var todo model.Todo
		err := cursor.Decode(&todo)
		if err != nil {
			return nil, err
		}
		highestID, _ = strconv.Atoi(todo.ID)
	}

	// Increment the highest ID to assign to the new todo
	newID := highestID + 1

	todo := &model.Todo{
		Text: input.Text,
		ID:   strconv.Itoa(newID),
		User: &model.User{ID: input.UserID, Name: "user " + input.UserID},
	}

	// Insert the todo document into MongoDB
	_, err = collection.InsertOne(ctx, todo)
	if err != nil {
		return nil, err
	}

	return todo, nil
}

// DeleteTodo is the resolver for the deleteTodo field.
func (r *mutationResolver) DeleteTodo(ctx context.Context, id string) (*model.Todo, error) {
	// First, find the todo document in MongoDB by ID.
	filter := bson.M{"id": id}
	collection := r.MongoDB.Database("admin").Collection("todos")
	var deletedTodo model.Todo
	if err := collection.FindOneAndDelete(ctx, filter).Decode(&deletedTodo); err != nil {
		return nil, err
	}

	return &deletedTodo, nil
}

// UpdateTodo is the resolver for the updateTodo field.
func (r *mutationResolver) UpdateTodo(ctx context.Context, id string, text *string, done *bool) (*model.Todo, error) {
	// Create a filter to find the todo by ID
	filter := bson.M{"id": id}

	// Check if the todo with the given ID exists in the database
	collection := r.MongoDB.Database("admin").Collection("todos")
	if count, err := collection.CountDocuments(ctx, filter); err != nil {
		return nil, err
	} else if count == 0 {
		return nil, fmt.Errorf("todo with ID %s not found", id)
	}

	// Create an update document with the fields to be updated
	update := bson.M{}
	if text != nil {
		update["text"] = *text
	}
	if done != nil {
		update["done"] = *done
	}

	// Perform the update operation in the MongoDB database
	if _, err := collection.UpdateOne(ctx, filter, bson.M{"$set": update}); err != nil {
		return nil, err
	}

	// Fetch the updated todo from the database
	var updatedTodo model.Todo
	if err := collection.FindOne(ctx, filter).Decode(&updatedTodo); err != nil {
		return nil, err
	}

	return &updatedTodo, nil
}

// Todos is the resolver for the todos field.
func (r *queryResolver) Todos(ctx context.Context) ([]*model.Todo, error) {
	// Query all todos from MongoDB
	collection := r.MongoDB.Database("admin").Collection("todos")
	cursor, err := collection.Find(ctx, bson.M{})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)

	var todos []*model.Todo
	for cursor.Next(ctx) {
		var todo model.Todo
		if err := cursor.Decode(&todo); err != nil {
			return nil, err
		}
		todos = append(todos, &todo)
	}

	return todos, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
